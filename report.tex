\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}

\usepackage{bbold}
\usepackage{bm}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage[margin=2.5cm]{geometry}

\usepackage{float}

\begin{document}


% ==============================================================================

\title{\Large{INFO8006: Project 2 - Report}}
\vspace{1cm}
\author{\small{\bf Maxime Goffart - s180521} \\ \small{\bf Olivier Joris - s182113}}

\maketitle

% ==============================================================================

\section{Problem statement}

\begin{enumerate}[label=\alph*.,leftmargin=*]
    \item
    	\begin{itemize}
    		\item (Initial state) A game state is given by the position of Pacman, the position of the ghost, and the positions of the remaining food dots in the maze.\\
    		The initial state is given by the layout of the maze, the initial position of Pacman, the initial position of the ghost, and the initial positions of all the food dots in the maze.
    		
    		\item (Player function) The player function is a function that takes a state as input and returns a value corresponding to the player who has to play. It respects this principle : an agent takes an action then the other takes one and so on. It is a turn taking game.
    		
    		\item (Actions) Pacman and the ghost can go north, south, east, or west if they don't go through a wall. Both of them can, also, stay on the same cell.\\
    		If Pacman arrives on a cell with a food, Pacman eats the food.\\
    		If the ghost arrives on the cell where Pacman is, the ghost kills Pacman.
    		
    		\item (Terminal test) True if Pacman has eaten all the foods without being killed or Pacman was killed by the ghost.
    		
    		\item (Transition model) The movement of Pacman or the ghost to another cell will modified their position in the maze (if the movement is legal). If Pacman eats a food, the food is removed from the maze. If the ghost kills Pacman, Pacman is removed from the maze and can no longer play.
    		
    		%\item (Utility)\\
    		%	\begin{equation}
  			%		utility(s,p)=\left\{
    		%			\begin{array}{@{} l c @{}}
      		%				\text{initial number of foods} & s = \text{Pacman wins and } p = \text{Pacman}\\
      		%				- \text{initial number of foods} & s = \text{Ghost wins}
    		%			\end{array}\right.
  			%	\label{eq4}
			%\end{equation}
			
			\item (Utility) Given a game state and a player function, the utility can be described as following : $Utility(s, p) = Game \ score(s)$ where $Game \ score(s)$ is the game score of the actual state s
    	\end{itemize}
    	
    \item Pacman will be the max agent and the ghost will be the min agent. Pacman wants to maximize the utility function (which implies maximizing the game score) by eating all the food dots in a minimum time steps and avoiding the ghost.\\
          The ghost, on his side, wants to kill Pacman as fast as possible to minimize the utility function (which implies minimizing the game score). This description makes the game of Pacman a zero-sum game because the total payoff to the two players is constant for all games.
\end{enumerate}

\section{Implementation}

\begin{enumerate}[label=\alph*.,leftmargin=*]
    \item Minimax is complete if the game tree is finite. For the game of Pacman, in general, the game tree is finite because either Pacman will eat all the food dots or the ghost will kill Pacman. However, if the ghost keeps chasing Pacman without being able to kill it and Pacman is not able to eat all the food dots, the algorithm will never end.\\
    %We could limit the recursion of the minimax algorithm. This is equivalent to adding a condition in the terminal test which will end the game on a draw after a given number of moves and returning 0 as a utility for both agent.
    As for the A$^*$ graph-search algorithm, we could keep a set which will remember the game states already considered so we don't spend computing time to recompute them. This will prevent Pacman and the ghost to do the same movements indefinitely.
    \item \textbf{\textit{Leave empty.}}
    \item \textbf{\textit{Leave empty.}}
	\item 
		\begin{itemize}
			\item The cuttoff-test/evaluation pair implemented in \texttt{hminimax0.py} is :
				\begin{itemize}
					\item Cuttoff-test function: $pacmanClosestFoodDistance < ghostFoodDistance \ or \ depth \geq 4$
					\item Evaluation function : $score \ - \ pacmanClosestFoodDistance \ - \ 3 \ * \ numFoodsLeft \ + \ 1 \ / \ pacmanGhostDistance$\\
					
					In these functions, for a given state, \textit{pacmanClosestFoodDistance} represents the actual distance between Pacman and the food dot which is actually the closest to him, \textit{ghostFoodDistance} represents the actual distance between this food dot and the ghost, \textit{depth} represents the actual explored depth of the game tree, \textit{score} represents the actual score of the game, \textit{numFoodsLeft} represents the actual number of remaining food dots, and \textit{pacmanGhostDistance} represents the actual distance between Pacman and the ghost.\\
					
					This cuttoff-test/evaluation pair allows to cut the exploration of the game tree when Pacman is closer to the nearest food dot to him than the ghost is or at a certain explored depth (fixed here at 4 which is sufficient for the given layouts) of the game tree. This additional condition is used to make sure that the minimax algorithm get cut at a sufficiently early moment. Then, this pair allow us to evaluate a state in this way : the higher score, the better, the closest Pacman to a food dot is, the better, the less food dots, the better, and the farthest Pacman is from the ghost, the better. The evaluation function is then a linear combination of this information allowing to choose a certain weight for each of them as a coefficient.\\
				\end{itemize} 

			\item The cuttoff-test/evaluation pair implemented in \texttt{hminimax1.py} is :
				\begin{itemize}
					\item Cuttoff-test function: $pacmanGhostDistance \leq pacmanClosestFoodDistance \ or \ depth \geq 4$
					\item Evaluation function : $score \ - \ pacmanClosestFoodDistance \ - \ 3 \ * \ numFoodsLeft \ + \ 1 \ / \ pacmanGhostDistance$\\
				
					In these functions, for a given state, all the feature names represents the same as in the first couple of functions.\\
				
					This cuttoff-test/evaluation pair allows to cut the exploration of the game tree when Pacman is closer to the nearest food dot to him than he is from the ghost or at a certain explored depth (fixed here at 4 which is sufficient for the given layouts) of the game tree. This additional condition is used to make sure that the minimax algorithm get cut at a sufficiently early moment. Then, the evaluation function is the same as the first one.\\
				\end{itemize}

			\item The cuttoff-test/evaluation pair implemented in \texttt{hminimax2.py} is :
				\begin{itemize}
					\item Cuttoff-test function: $depth \geq 5$
					\item Evaluation function : $- \ 10 \ * \ numFoodsLeft \ + \ pacmanGhostDistance$\\
				
					In these functions, for a given state, all the feature names represents the same as in the first couples of functions.\\
				
					This cuttoff-test/evaluation pair allows to cut the exploration of the game tree at a certain explored depth (fixed here at 5) of the game tree. Then, the evaluation function only takes into account the number of remaining food dots and the actual distance between Pacman and the ghost with coefficients to give a certain weight to them.\\
				\end{itemize}
		\end{itemize}
\end{enumerate}

\section{Experiment}
a.
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.75]{plots/3a_scores.png} 
			\caption{Comparison of the scores of the different cutoff-test/eval pairs in the large layout.}
		\end{figure}

		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.75]{plots/3a_nodes.png} 
			\caption{Comparison of the expanded nodes of the different cutoff-test/eval pairs in the large layout.}
		\end{figure}

		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.75]{plots/3a_times.png} 
			\caption{Comparison of the computation times of the different cutoff-test/eval pairs in the large layout.}
		\end{figure}
\begin{enumerate}[label=\alph*.,leftmargin=*]	
	\item[b.] The two first cuttoff-test/evaluation pairs allow Pacman to win against all the ghosts in all the layouts with a similar respectable score, number of expanded nodes, and computation time.\\
	However, using the third one, Pacman is winning against all the ghosts in all the layouts except against the dumby ghost in the large layout. It can be explain by the fact that unlike the other ghosts, the dumby ghost is not chasing Pacman which implies our evaluation function making Pacman cycling a bit like the ghost is doing. We can also see that the scores, numbers of expanded nodes, and computation times are less satisfying with this pair.\\
	Moreover, this last cuttoff-test only takes into account the actual explored depth of the game tree which can implies to cut the minimax algorithm at an inappropriate moment (horizon effect).

    \item[c.] To handle several ghosts, we need to label states with utility tuples (1 value per player). Each player will now want to maximize its own value, it can give rise to cooperation between agents (for example, ghosts here). The game can no longer be described as a zero-sum game because the total payoff to all players is no longer constant.

\end{enumerate}

% ==============================================================================

\end{document}